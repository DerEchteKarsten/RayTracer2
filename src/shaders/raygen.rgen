#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

layout( push_constant ) uniform Frame {
	uint frame;
	uint moved;
} f;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT Payload {
	bool missed;
	float metallicFactor;
  	float roughness;
	vec3 color;
  	vec3 emission;
	vec3 hitPoint;
	vec3 hitNormal;
} p;

#define PI 3.1415926

uint NextRandom(inout uint state) {
	state = state * 747796405 + 2891336453;
	uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

float RandomValue(inout uint state) {
	return NextRandom(state) / 4294967295.0;
}

float RandomValueNormalDistribution(inout uint state) {
	float theta = 2 * 3.1415926 * RandomValue(state);
	float rho = sqrt(-2 * log(RandomValue(state)));
	return rho * cos(theta);
}

vec3 RandomDirection(inout uint state) {
	float x = RandomValueNormalDistribution(state);
	float y = RandomValueNormalDistribution(state);
	float z = RandomValueNormalDistribution(state);
	return normalize(vec3(x,y,z));
}

const float tmin = 0.1;
const float tmax = 10000.0;

float FresnelSchlickRoughness( float cosTheta, float F0, float roughness ) {
    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);
}

vec3 modifyDirectionWithRoughness( const vec3 normal, const vec3 n, const float roughness, inout uint state ) {
    vec2 r = vec2(RandomValue(state), RandomValue(state));
    
	vec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));
	vec3  vv = cross(uu, n);
	
    float a = roughness*roughness;
    
	float rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));
	float ra = sqrt(abs(1.-rz*rz));
	float rx = ra*cos(6.28318530718*r.x); 
	float ry = ra*sin(6.28318530718*r.x);
	vec3  rr = vec3(rx*uu + ry*vv + rz*n);
    
    vec3 ret = normalize(rr);
    return dot(ret,normal) > 0. ? ret : n;
}


vec3 Trace(vec3 direction, vec3 origin, inout uint state) {
	vec3 incomingLight = vec3(0.0);
	vec3 rayColor = vec3(1.0);

	for (int i = 0; i <= 10; i++) {
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);
		if (!p.missed) {
			if (f.moved == 1) {
				return p.color;
			}

			origin = p.hitPoint;
			vec3 sepecular = reflect(direction, p.hitNormal);
			vec3 difuse = normalize(p.hitNormal + RandomDirection(state));
			incomingLight += p.emission * 10 * rayColor;

            float F = FresnelSchlickRoughness(max(0.,-dot(p.hitNormal, direction)), .04, p.roughness);

			if (F > RandomValue(state)) {
				direction = modifyDirectionWithRoughness(p.hitNormal, reflect(direction,p.hitNormal), p.roughness, state);
			} else {
				rayColor *= p.color;
				direction = normalize(p.hitNormal + RandomDirection(state));
			}

			float p = max(rayColor.r, max(rayColor.g, rayColor.b));
			if (RandomValue(state) >= p) {
				break;
			}
			rayColor *= 1.0 / p; 
		}else {
			// const float dotp = dot(direction, normalize(vec3(1.0, 10.0, 1.0)));
			// if (dotp > 0.9) {
			// 	incomingLight += dotp * vec3(0.99215, 0.9843, 0.82745) * 40 * rayColor;
			// }
			break;
		}
	}
	return incomingLight;
}
const int raysPerPixel = 10;

void main() 
{	
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

	uint rngState = uint((gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x) + gl_LaunchIDEXT.x) + uint(f.frame) * 23145;

	vec3 totalLight = vec3(0.0);

	for (int ray = 0; ray < raysPerPixel; ray++) {
		vec3 incomingLight = Trace(direction.xyz, origin.xyz, rngState);
		totalLight += incomingLight;
	}

	vec3 pixelCol = totalLight / raysPerPixel;
	vec3 color;
	if (f.moved == 0) {
		float a =1.0 / float(f.frame+1.0);
		vec3 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
		color = vec3(mix(oldColor, pixelCol, a));
	}else{
		color = pixelCol;
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color,1.0));
}