#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_GOOGLE_include_directive : enable

layout( push_constant ) uniform Frame {
	uint frame;
	uint moved;
} f;

layout(binding = 0, set = 1, r32f) uniform image2D u_GBufferDepth;
layout(binding = 1, set = 1, r32ui) uniform uimage2D u_GBufferNormals;
layout(binding = 2, set = 1, r32ui) uniform uimage2D u_GBufferGeoNormals;
layout(binding = 3, set = 1, r32ui) uniform uimage2D u_GBufferDiffuseAlbedo;
layout(binding = 4, set = 1, r32ui) uniform uimage2D u_GBufferSpecularRough;
layout(binding = 5, set = 1, rgba32f) uniform image2D u_MotionVectors;

#include "common.glsl"
layout(location = 0) rayPayloadEXT Payload p;
#define RTXDI_ENABLE_PRESAMPLING 0
#define RTXDI_GLSL
#include "RtxdiApplicationBridge.glsl"
#include "PrimaryRays.glsl"
#include "rtxdi/InitialSamplingFunctions.hlsli"
#include "rtxdi/GIResamplingFunctions.hlsli"


vec2 octWrap(vec2 v)
{
    return (1.f - abs(v.yx)) * ((v.x >= 0.f || v.y >= 0.f) ? 1.f : -1.f);
}

vec2 ndirToOctSigned(vec3 n)
{
    // Project the sphere onto the octahedron (|x|+|y|+|z| = 1) and then onto the xy-plane
    vec2 p = n.xy * (1.f / (abs(n.x) + abs(n.y) + abs(n.z)));
    return (n.z < 0.f) ? octWrap(p) : p;
}

uint ndirToOctUnorm32(vec3 n)
{
    vec2 p = ndirToOctSigned(n);
    p = saturate(p.xy * 0.5 + 0.5);
    return uint(p.x * 0xfffe) | (uint(p.y * 0xfffe) << 16);
}


void branchlessONB(in vec3 n, out vec3 b1, out vec3 b2)
{
    float sign = n.z >= 0.0f ? 1.0f : -1.0f;
    float a = -1.0f / (sign + n.z);
    float b = n.x * n.y * a;
    b1 = vec3(1.0f + sign * n.x * n.x * a, sign * b, -sign * n.x);
    b2 = vec3(b, sign + n.y * n.y * a, -n.y);
}


vec3 sampleGGX_VNDF(vec3 Ve, float roughness, vec2 random)
{
    float alpha = square(roughness);

    vec3 Vh = normalize(vec3(alpha * Ve.x, alpha * Ve.y, Ve.z));

    float lensq = square(Vh.x) + square(Vh.y);
    vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
    vec3 T2 = cross(Vh, T1);

    float r = sqrt(random.x);
    float phi = 2.0 * RTXDI_PI * random.y;
    float t1 = r * cos(phi);
    float t2 = r * sin(phi);
    float s = 0.5 * (1.0 + Vh.z);
    t2 = (1.0 - s) * sqrt(1.0 - square(t1)) + s * t2;

    vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - square(t1) - square(t2))) * Vh;

    // Tangent space H
    vec3 Ne = vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z));
    return Ne;
}

float G1_Smith(float roughness, float NdotL)
{
    float alpha = square(roughness);
    return 2.0 * NdotL / (NdotL + sqrt(square(alpha) + (1.0 - square(alpha)) * square(NdotL)));
}

const float EMISSION_STREANGTH = 20.0;
const float SKYBOX = 1.0;

void main() 
{	
	ivec2 size = ivec2(gl_LaunchSizeEXT.xy);
	ivec2 pixelCord = ivec2(gl_LaunchIDEXT.xy);

    PrimarySurfaceOutput primary = TracePrimaryRay(pixelCord);

    imageStore(u_GBufferDepth, pixelCord, vec4(primary.surface.viewDepth)); 
    imageStore(u_GBufferNormals, pixelCord, uvec4(ndirToOctUnorm32(primary.surface.normal))); 
    imageStore(u_GBufferGeoNormals, pixelCord, uvec4(ndirToOctUnorm32(primary.surface.geoNormal))); 
    imageStore(u_GBufferDiffuseAlbedo, pixelCord, uvec4(Pack_R11G11B10_UFLOAT(primary.surface.diffuseAlbedo))); 
    imageStore(u_GBufferSpecularRough, pixelCord, uvec4(Pack_R8G8B8A8_Gamma_UFLOAT(vec4(primary.surface.specularF0, primary.surface.roughness)))); 
    imageStore(u_MotionVectors, pixelCord, vec4(primary.motionVector, 0.0));

    RTXDI_GIReservoir reservoir;

    vec3 emission = p.emission *EMISSION_STREANGTH;

    if (RAB_IsSurfaceValid(primary.surface))
    {
        RAB_RandomSamplerState rng = RAB_InitRandomSampler(pixelCord, 1);
        
        float dist = max(1, 0.1 * length(primary.surface.worldPos - g_Const.view.cameraDirectionOrPosition.xyz));

        RayDesc ray;
        ray.TMin = 0.001f * dist;
        ray.TMax = 1000;

        float3 tangent, bitangent;
        branchlessONB(primary.surface.normal, tangent, bitangent);

        float2 Rand;
        Rand.x = RAB_GetNextRandom(rng);
        Rand.y = RAB_GetNextRandom(rng);

        float3 V = normalize(g_Const.view.cameraDirectionOrPosition.xyz - primary.surface.worldPos);

        bool isSpecularRay = false;
        bool isDeltaSurface = primary.surface.roughness == 0.0;
        float specular_PDF;
        float3 BRDF_over_PDF;
        float overall_PDF;

        {
            float3 specularDirection;
            float3 specular_BRDF_over_PDF;
            {
                float3 Ve = float3(dot(V, tangent), dot(V, bitangent), dot(V, primary.surface.normal));
                float3 He = sampleGGX_VNDF(Ve, primary.surface.roughness, Rand);
                float3 H = isDeltaSurface ? primary.surface.normal : normalize(He.x * tangent + He.y * bitangent + He.z * primary.surface.normal);
                specularDirection = reflect(-V, H);

                float HoV = saturate(dot(H, V));
                float NoV = saturate(dot(primary.surface.normal, V));
                float3 F = Schlick_Fresnel(primary.surface.specularF0, HoV);
                float G1 = isDeltaSurface ? 1.0 : (NoV > 0) ? G1_Smith(primary.surface.roughness, NoV) : 0;
                specular_BRDF_over_PDF = F * G1;
            }

            float3 diffuseDirection;
            float diffuse_BRDF_over_PDF;
            {
                float solidAnglePdf;
                float3 localDirection = SampleCosHemisphere(Rand, solidAnglePdf);
                diffuseDirection = tangent * localDirection.x + bitangent * localDirection.y + primary.surface.normal * localDirection.z;
                diffuse_BRDF_over_PDF = 1.0;
            }

            specular_PDF = saturate(calcLuminance(specular_BRDF_over_PDF) /
                calcLuminance(specular_BRDF_over_PDF + diffuse_BRDF_over_PDF * primary.surface.diffuseAlbedo));

            isSpecularRay = RAB_GetNextRandom(rng) < specular_PDF;

            if (isSpecularRay)
            {
                ray.Direction = specularDirection;
                BRDF_over_PDF = specular_BRDF_over_PDF / specular_PDF;
            }
            else
            {
                ray.Direction = diffuseDirection;
                BRDF_over_PDF = vec3(diffuse_BRDF_over_PDF / (1.0 - specular_PDF));
            }

            const float specularLobe_PDF = ImportanceSampleGGX_VNDF_PDF(primary.surface.roughness, primary.surface.normal, V, ray.Direction);
            const float diffuseLobe_PDF = saturate(dot(ray.Direction, primary.surface.normal)) / RTXDI_PI;

            // For delta surfaces, we only pass the diffuse lobe to ReSTIR GI, and this pdf is for that.
            overall_PDF = isDeltaSurface ? diffuseLobe_PDF : mix(diffuseLobe_PDF, specularLobe_PDF, specular_PDF);
        }

        if (dot(primary.surface.geoNormal, ray.Direction) <= 0.0)
        {
            BRDF_over_PDF = vec3(0.0);
            ray.TMax = 0;
        }

        ray.Origin = primary.surface.worldPos;

        RAB_Surface secondarySurface = TraceRayToSurface(ray);

        if(RAB_IsSurfaceValid(secondarySurface)) {
            RayDesc ray;
            ray.TMin = tmin;
            ray.TMax = BACKGROUND_DEPTH;
            ray.Origin = secondarySurface.worldPos;
            vec3 dir; 
            RAB_GetSurfaceBrdfSample(secondarySurface, rng, dir);
            ray.Direction = dir;
            trace(ray);

            SplitBrdf brdf;
            vec3 radiance;
            if(!p.missed) {
                brdf = EvaluateBrdf(secondarySurface, p.hitPoint);
                radiance = p.emission * EMISSION_STREANGTH;
            }else {
                brdf = EvaluateBrdf(secondarySurface, ray.Origin + ray.Direction * BACKGROUND_DEPTH);
                radiance = p.color.rgb * SKYBOX;
            }

            vec3 diffuse = brdf.demodulatedDiffuse * radiance;
			vec3 specular = brdf.specular * radiance;

            specular = DemodulateSpecular(specular, secondarySurface.specularF0);

            diffuse.rgb *= secondarySurface.diffuseAlbedo;
            specular.rgb *= max(vec3(0.01), secondarySurface.specularF0);

            reservoir = RTXDI_MakeGIReservoir(secondarySurface.worldPos,
                secondarySurface.geoNormal, (diffuse + specular + emission + p.emission * EMISSION_STREANGTH), overall_PDF);

        }else {
            reservoir = RTXDI_MakeGIReservoir(ray.Origin + ray.Direction * BACKGROUND_DEPTH,
                -ray.Direction, (p.color.rgb * SKYBOX + emission), overall_PDF);
        }
    }
    else
    {
        reservoir = RTXDI_EmptyGIReservoir();
    }
    
    RTXDI_StoreGIReservoir(reservoir, g_Const.restirGI.reservoirBufferParams, pixelCord, g_Const.restirGI.bufferIndices.secondarySurfaceReSTIRDIOutputBufferIndex);
}