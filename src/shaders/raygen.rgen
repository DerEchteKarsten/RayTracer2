#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"
layout(location = 0) rayPayloadEXT Payload p;
#define RTXDI_ENABLE_PRESAMPLING 0
#define RTXDI_GLSL
#include "RtxdiApplicationBridge.glsl"

#include "rtxdi/InitialSamplingFunctions.hlsli"
#include "rtxdi/GIResamplingFunctions.hlsli"

layout( push_constant ) uniform Frame {
	uint frame;
	uint moved;
} f;

layout(binding = 2, set = 1, rgba32f) uniform writeonly image2D image;

const int MaxAlphaSurfaces = 1;

vec3 trace(vec3 o, vec3 d) {
	vec3 rayColor = vec3(1.0);

	for (int t = 0; t<=MaxAlphaSurfaces; t++ ) {
		traceRayEXT(SceneBVH, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, o, tmin, d, tmax, 0);
		rayColor *= p.color.rgb;
		if (p.color.a < 1.0) {
			o = p.hitPoint;
		}else {
			break;
		}
	}
	return rayColor;
}


const int MaxBounces = 2; 
const int MaxSamples = 1;
Sample Trace2(in vec3 origin, in vec3 direction, inout uint state) {
	vec3 incomingLight = vec3(0.0);
	vec3 rayColor = vec3(1.0);
	Sample s = Sample(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));

	rayColor *= trace(origin, direction);
	if (!p.missed) {
		s.p_pos = p.hitPoint;
		s.p_normal = p.hitNormal;

		incomingLight = p.emission * 12 * rayColor;

		origin = p.hitPoint;
		direction = normalize(p.hitNormal + RandomDirection(state));

		rayColor *= trace(origin, direction);
		if (!p.missed) {
			s.s_pos = p.hitPoint;
			s.s_normal = p.hitNormal;

			incomingLight += p.emission * 12 * rayColor;

			origin = p.hitPoint;
			direction = normalize(p.hitNormal + RandomDirection(state));

			rayColor *= trace(origin, direction);
			if(!p.missed) {
				incomingLight += p.emission * 12 * rayColor;
			}else {
				incomingLight += p.color.rgb * rayColor;
			}
		} else {
			s.s_pos = origin + direction * tmax;
			s.s_normal = -direction;

			incomingLight += p.color.rgb * rayColor;
		}
	}else {
		s.p_pos = origin + direction * tmax;
		s.p_normal = -direction;

		s.s_pos = origin + direction * tmax;
		s.s_normal = -direction;

		incomingLight = p.color.rgb; //skybox
	}
	
	s.radiance = incomingLight;
	return s;
}

const int SPACIAL_SAMPELS = 8;

void CalculatePartialJacobian(const vec3 recieverPos, const vec3 samplePos, const vec3 sampleNormal,
    out float distanceToSurface, out float cosineEmissionAngle)
{
    vec3 vec = recieverPos - samplePos;

    distanceToSurface = length(vec);
    cosineEmissionAngle = clamp(dot(sampleNormal, vec / distanceToSurface), 0, 1);
}

float CalculateJacobian(vec3 recieverPos, vec3 neighborReceiverPos, const Reservoir neighborReservoir)
{
    // Calculate Jacobian determinant to adjust weight.
    // See Equation (11) in the ReSTIR GI paper.
    float originalDistance, originalCosine;
    float newDistance, newCosine;
    CalculatePartialJacobian(recieverPos, neighborReservoir.z.s_pos, neighborReservoir.z.s_normal, newDistance, newCosine);
    CalculatePartialJacobian(neighborReceiverPos, neighborReservoir.z.s_pos, neighborReservoir.z.s_normal, originalDistance, originalCosine);

    float jacobian = (newCosine * originalDistance * originalDistance)
        / (originalCosine * newDistance * newDistance);

    if (isinf(jacobian) || isnan(jacobian))
        jacobian = 0;

    return jacobian;
}

ivec2 CalculateTemporalResamplingOffset(int sampleIdx, int radius)
{
    sampleIdx &= 7;

    int mask2 = sampleIdx >> 1 & 0x01;       // 0, 0, 1, 1, 0, 0, 1, 1
    int mask4 = 1 - (sampleIdx >> 2 & 0x01); // 1, 1, 1, 1, 0, 0, 0, 0
    int tmp0 = -1 + 2 * (sampleIdx & 0x01);  // -1, 1,....
    int tmp1 = 1 - 2 * mask2;                // 1, 1,-1,-1, 1, 1,-1,-1
    int tmp2 = mask4 | mask2;                // 1, 1, 1, 1, 0, 0, 1, 1
    int tmp3 = mask4 | (1 - mask2);          // 1, 1, 1, 1, 1, 1, 0, 0

    return ivec2(tmp0, tmp0 * tmp1) * ivec2(tmp2, tmp3) * radius;
}

uint to_index(ivec2 val) {
	return val.y * ivec2(gl_LaunchSizeEXT.xy).x + val.x;
}


void main() 
{	
	ivec2 size = ivec2(gl_LaunchSizeEXT.xy);
	ivec2 pixelCord = ivec2(gl_LaunchIDEXT.xy);

	const vec2 pixelCenter = vec2(pixelCord.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(size);
	vec2 d = inUV * 2.0 - 1.0;
	vec2 dir = inUV * 2.0 - 1.0;
	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(dir.x, dir.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

	uint rngState = uint((pixelCord.y * size.x) + pixelCord.x) + uint(f.frame) * 23145;
	uint q = to_index(pixelCord);

	Sample s = Trace2(origin.xyz, direction.xyz, rngState);
	Reservoir r;
	if(f.frame == 0) {
		r = Reservoir(s, 0.0, 1, 0.0);
		reservoirs[q] = r;
		old_reservoirs[q] = r;
	}else {
		r = old_reservoirs[q];
		if(r.z.p_pos != s.p_pos) { // todo reprojection
			r = Reservoir(s, 0.0, 1, 0.0);
		}else {
			float weight = length(s.radiance)/(1/(2*PI));
			update(r, s, weight, rngState);
			r.weight = r.weight_sum / (r.num_sampels * length(s.radiance));
		}
		uint SampleNumAccum = 0;
		for(int i = 0; i < SPACIAL_SAMPELS; ++i) {
			uint neigbur_pixel = to_index(pixelCord + CalculateTemporalResamplingOffset(i, 3));
			//todo gbuffer
			Reservoir neighbur_reservoir = old_reservoirs[neigbur_pixel];
			if(s.p_normal != neighbur_reservoir.z.p_normal) {
				continue;
			}

			float target_pdf = length(neighbur_reservoir.z.radiance);
			float jacobian = CalculateJacobian(s.s_pos, neighbur_reservoir.z.s_pos, r);

			if (jacobian > 10.0 || jacobian < 1 / 10.0) {
				continue;
			}

			jacobian = clamp(jacobian, 1 / 3.0, 3.0);

			merge(r, neighbur_reservoir, target_pdf / jacobian, rngState);
				
			SampleNumAccum += r.num_sampels;
			//todo bias correction
		}
		if(SampleNumAccum != 0) {
			r.weight = r.weight_sum/(SampleNumAccum*length(r.z.radiance));
		}
		reservoirs[q] = r;
	}

	imageStore(image, pixelCord, vec4(r.z.radiance, 1.0));
}