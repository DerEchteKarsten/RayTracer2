#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_GOOGLE_include_directive : enable

#include "./restir.glsl"

layout( push_constant ) uniform Frame {
	uint frame;
	uint moved;
} f;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
// layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;
layout(location = 0) rayPayloadEXT Payload p;

layout(binding = 9, set = 0) writeonly buffer InitialSamples {
	Sample initialSamples[];
} is;

vec3 Trace(vec3 direction, vec3 origin, inout uint state) {
	vec3 incomingLight = vec3(0.0);
	vec3 rayColor = vec3(1.0);

	for (int i = 0; i <= 15; i++) {
		for (int t = 0; t<=5; t++ ) {
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);
			if (p.color.a == 0.0) {
				origin = p.hitPoint;
			}else {
				break;
			}
		}
		if (!p.missed) {
			if (f.moved == 1) {
                return p.color.rgb;
            }
            origin = p.hitPoint;
            incomingLight += p.emission * 12 * rayColor;

            float F = FresnelSchlickRoughness(max(0.,-dot(p.hitNormal, direction)), p.metallicFactor, p.roughness);

            if (F > RandomValue(state)) {
                direction = modifyDirectionWithRoughness(p.hitNormal, reflect(direction,p.hitNormal), p.roughness, state);
            } else {
                rayColor *= p.color.rgb;
				vec3 rand_dir = RandomDirection(state);
                direction = normalize(p.hitNormal + rand_dir);
            }

            float p = max(rayColor.r, max(rayColor.g, rayColor.b));
            if (RandomValue(state) >= p) {
                break;
            }
            rayColor *= 1.0 / p;
		}else {
			// const float dotp = dot(direction, normalize(vec3(1.0, 10.0, 1.0)));
			// if (dotp > 0.9) {
			// 	incomingLight += dotp * vec3(0.99215, 0.9843, 0.82745) * 200 * rayColor;
			// }
			break;
		}
	}
	return incomingLight;
}


const int MaxBounces = 2; 
const int MaxAlphaSurfaces = 5;

Sample initial_sampling(vec3 direction, vec3 origin, inout uint state) {
	vec3 rayColor = vec3(1.0);
	Sample s = Sample(vec3(0), vec3(0), vec3(0),vec3(0), vec3(0),vec3(0),vec3(0), 0);
    for (int i = 0; i <= MaxBounces; i++) {
        for (int t = 0; t<= MaxAlphaSurfaces; t++ ) {
            traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);
			s.depth += p.depth;
            if (p.color.a == 0.0) {
                origin = p.hitPoint;
            }else {
                break;
            }
        }

        if (!p.missed) {
            origin = p.hitPoint;
            s.radiance += p.emission * 6 * rayColor;
			rayColor *= p.color.rgb;
			direction = normalize(p.hitNormal + RandomDirection(state));
			
            if (i == 0) {
				s.albedo = p.color.rgb;
                s.origin = p.hitPoint;
                s.originNormal = p.hitNormal;
				s.randomDirection = direction;
            } else if (i == 1) {
                s.samplePoint = p.hitPoint;
                s.samplePointNormal = p.hitNormal;
            }
        }else{
			if (i == 0) {
				s.originNormal = direction;
			}
			break;
		}
    }
    return s;
}

void main() 
{	
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

	uint rngState = uint((gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x) + gl_LaunchIDEXT.x) + uint(f.frame) * 23145;

	Sample s = initial_sampling(direction.xyz, origin.xyz, rngState);

	// vec3 color = s.radiance;
	// if (f.moved == 0) {
	// 	float a = 1.0 / float(f.frame+1.0);
	// 	vec3 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
	// 	color = vec3(mix(oldColor, color, a));
	// } else {
	// 	color = s.radiance; 
	// }

	// vec3 totalLight = vec3(0.0);
	// for (int ray = 0; ray < raysPerPixel; ray++) {
	// 	vec3 incomingLight = Trace(direction.xyz, origin.xyz, rngState);
	// 	totalLight += incomingLight;
	// }

	// vec3 pixelCol = totalLight / raysPerPixel;
	// vec3 color;
	// if (f.moved == 0) {
	// 	float a =1.0 / float(f.frame+1.0);
	// 	vec3 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
	// 	color = vec3(mix(oldColor, pixelCol, a));
	// }else{
	// 	color = pixelCol;
	// }
	is.initialSamples[(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x) + gl_LaunchIDEXT.x] = s;
}