#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_GOOGLE_include_directive : enable

// #include "./restir.glsl"

#include "common.glsl"

layout( push_constant ) uniform Frame {
	uint frame;
	uint moved;
} f;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 1, rgba32f) uniform readonly image2D colorImage;
layout(binding = 2, set = 1, rgba32f) uniform readonly image2D positionImage;
layout(binding = 3, set = 1, rgba32f) uniform readonly image2D normalImage;
layout(binding = 4, set = 1, rgba32f) uniform writeonly image2D image;
layout(binding = 4, set = 2, rgba32f) uniform readonly image2D last_image;

layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;
layout(location = 0) rayPayloadEXT Payload p;

// layout(binding = 9, set = 0) writeonly buffer InitialSamples {
// 	Sample initialSamples[];
// } is;

const int MaxBounces = 3; 
const int MaxAlphaSurfaces = 5;
vec3 Trace(in vec3 origin, in vec3 rayColor, inout uint state, in vec3 normal) {
	vec3 totalLight = vec3(0.0);
	vec3 direction = vec3(1.0, 0.0, 0.0);

	for (int b = 0; b < MaxBounces; b++) {
		// float F = FresnelSchlickRoughness(max(0.,-dot(p.hitNormal, direction)), p.metallicFactor, p.roughness);
		// bool specular = F > RandomValue(state);
		// if (specular) {
		// 	direction = modifyDirectionWithRoughness(p.hitNormal, reflect(direction,p.hitNormal), p.roughness, state);
		// } else {
			direction = normalize(normal + RandomDirection(state));
			normal = p.hitNormal;
		// }
		for (int t = 0; t<=MaxAlphaSurfaces; t++ ) {
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);
			if (p.color.a < 1.0) {
				origin = p.hitPoint;
				rayColor *= p.color.rgb * p.color.a;
			}else {
				break;
			}
		}
		if (!p.missed) {
			origin = p.hitPoint;
			totalLight += p.emission * 12 * rayColor;
			// if (!specular) {
				rayColor *= p.color.rgb;
			// }
		}else {
			// const float dotp = dot(direction, normalize(vec3(1.0, 10.0, 1.0)));
			// if (dotp > 0.9) {
			// 	incomingLight += dotp * vec3(0.99215, 0.9843, 0.82745) * 200 * rayColor;
			// }
			break;
		}
	}
	return totalLight;
}


const int MaxSamples = 4;
vec3 Trace2(in vec3 direction, in vec3 origin, inout uint state) {
	vec3 totalLight = vec3(0.0);

	for (int s = 0; s < MaxSamples; s++) {
		vec3 o = origin;
		vec3 d = direction;
		vec3 incomingLight = vec3(0.0);
		vec3 rayColor = vec3(1.0);
		for (int i = 0; i <= MaxBounces; i++) {
			for (int t = 0; t<=MaxAlphaSurfaces; t++ ) {
				traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, o, tmin, d, tmax, 0);
				if (p.color.a < 1.0) {
					o = p.hitPoint;
					rayColor *= p.color.rgb * p.color.a;
				}else {
					break;
				}
			}
			if (!p.missed) {
				o = p.hitPoint;
				incomingLight += p.emission * 12 * rayColor;

				float F = FresnelSchlickRoughness(max(0.,-dot(p.hitNormal, d)), p.metallicFactor, p.roughness);

				if (F > RandomValue(state)) {
					d = modifyDirectionWithRoughness(p.hitNormal, reflect(d,p.hitNormal), p.roughness, state);
				} else {
					rayColor *= p.color.rgb;
					d = normalize(p.hitNormal + RandomDirection(state));
				}
			}else {
				// const float dotp = dot(direction, normalize(vec3(1.0, 10.0, 1.0)));
				// if (dotp > 0.9) {
				// 	incomingLight += dotp * vec3(0.99215, 0.9843, 0.82745) * 200 * rayColor;
				// }
				break;
			}
		}
		totalLight += incomingLight;
	}

	return totalLight / MaxSamples;
}

void main() 
{	
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

	uint rngState = uint((gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x) + gl_LaunchIDEXT.x) + uint(f.frame) * 23145;

	// vec3 pixelCol = Trace2(direction.xyz, origin.xyz, rngState);
	vec3 albedo = imageLoad(colorImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
	vec3 pos = imageLoad(positionImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
	vec3 normal = imageLoad(normalImage, ivec2(gl_LaunchIDEXT.xy)).xyz;

	if (dot(normal, direction.xyz) < 0) {
		normal = reflect(normal, direction.xyz);
	}

	vec3 pixelCol;
	if (pos == vec3(0.0, 0.0, 0.0)) {
		pixelCol = vec3(0.0, 0.0, 0.0);
	}else {
		pixelCol = Trace(pos, albedo, rngState, normal);
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(pixelCol, 1.0));

	// vec3 color;
	// if (f.moved == 0) {
	// 	float a =1.0 / float(f.frame+1.0);
	// 	vec3 oldColor = imageLoad(last_image, ivec2(gl_LaunchIDEXT.xy)).xyz;
	// 	color = vec3(mix(oldColor, pixelCol, a));
	// }else{
	// 	color = pixelCol;
	// }
}