#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"
layout(location = 0) rayPayloadEXT Payload p;
#define RTXDI_ENABLE_PRESAMPLING 0
#define RTXDI_GLSL
#include "RtxdiApplicationBridge.glsl"
#include "PrimaryRays.glsl"
#include "rtxdi/InitialSamplingFunctions.hlsli"
#include "rtxdi/GIResamplingFunctions.hlsli"

layout( push_constant ) uniform Frame {
	uint frame;
	uint moved;
} f;

layout(binding = 2, set = 1, rgba32f) uniform writeonly image2D image;
layout(binding = 2, set = 1, r32f) uniform writeonly image2D u_GBufferDepth;
layout(binding = 3, set = 1, r32ui) uniform writeonly uimage2D u_GBufferNormals;
layout(binding = 4, set = 1, r32ui) uniform writeonly uimage2D u_GBufferGeoNormals;
layout(binding = 5, set = 1, r32ui) uniform writeonly uimage2D u_GBufferDiffuseAlbedo;
layout(binding = 6, set = 1, r32ui) uniform writeonly uimage2D u_GBufferSpecularRough;
layout(binding = 7, set = 1, rgba32f) uniform writeonly image2D u_MotionVectors;

vec2 octWrap(vec2 v)
{
    return (1.f - abs(v.yx)) * ((v.x >= 0.f || v.y >= 0.f) ? 1.f : -1.f);
}

vec2 ndirToOctSigned(vec3 n)
{
    // Project the sphere onto the octahedron (|x|+|y|+|z| = 1) and then onto the xy-plane
    vec2 p = n.xy * (1.f / (abs(n.x) + abs(n.y) + abs(n.z)));
    return (n.z < 0.f) ? octWrap(p) : p;
}

uint ndirToOctUnorm32(vec3 n)
{
    vec2 p = ndirToOctSigned(n);
    p = saturate(p.xy * 0.5 + 0.5);
    return uint(p.x * 0xfffe) | (uint(p.y * 0xfffe) << 16);
}

void main() 
{	
	ivec2 size = ivec2(gl_LaunchSizeEXT.xy);
	ivec2 pixelCord = ivec2(gl_LaunchIDEXT.xy);

    const RTXDI_LightBufferParameters lightBufferParams = g_Const.lightBufferParams;

    PrimarySurfaceOutput primary = TracePrimaryRay(pixelCord);

    imageStore(u_GBufferDepth, pixelCord, vec4(primary.surface.viewDepth)); 
    imageStore(u_GBufferNormals, pixelCord, uvec4(ndirToOctUnorm32(primary.surface.normal))); 
    imageStore(u_GBufferGeoNormals, pixelCord, uvec4(ndirToOctUnorm32(primary.surface.geoNormal))); 
    imageStore(u_GBufferDiffuseAlbedo, pixelCord, uvec4(Pack_R11G11B10_UFLOAT(primary.surface.diffuseAlbedo))); 
    imageStore(u_GBufferSpecularRough, pixelCord, uvec4(Pack_R8G8B8A8_Gamma_UFLOAT(vec4(primary.surface.specularF0, primary.surface.roughness)))); 
    imageStore(u_MotionVectors, pixelCord, vec4(primary.motionVector, 0.0));

    RTXDI_GIReservoir reservoir;

    if (RAB_IsSurfaceValid(primary.surface))
    {
        RAB_RandomSamplerState rng = RAB_InitRandomSampler(pixelCord, 1);
        
        RayDesc ray;
        ray.TMin = tmin;
        ray.TMax = tmax;
        ray.Origin = primary.surface.worldPos;
        vec3 dir; 
        RAB_GetSurfaceBrdfSample(primary.surface, rng, dir);
        ray.Direction = dir;

        RAB_Surface secondarySurface = TraceRayToSurface(ray);

        float overall_PDF = RAB_GetSurfaceBrdfPdf(primary.surface, dir);

        if(RAB_IsSurfaceValid(secondarySurface)) {
            reservoir = RTXDI_MakeGIReservoir(secondarySurface.worldPos,
                    secondarySurface.geoNormal, vec3(0.0), overall_PDF);
            
            RayDesc ray;
            ray.TMin = tmin;
            ray.TMax = tmax;
            ray.Origin = secondarySurface.worldPos;
            vec3 dir; 
            RAB_GetSurfaceBrdfSample(secondarySurface, rng, dir);
            ray.Direction = dir;
            trace(ray);
            
            if(!p.missed) {
                reservoir.radiance = vec3(0.0);
            }else {
                SplitBrdf brdf = EvaluateBrdf(secondarySurface, ray.Origin + ray.Direction * BACKGROUND_DEPTH);

                vec3 diffuse = brdf.demodulatedDiffuse * p.color.rgb; // used for skybox radiance
                vec3 specular = brdf.specular * p.color.rgb; // used for skybox radiance

                reservoir.radiance = diffuse + specular;
            }
        }else {
            reservoir = RTXDI_MakeGIReservoir(ray.Origin + ray.Direction * BACKGROUND_DEPTH,
                -ray.Direction, p.color.rgb, overall_PDF);
        }
    }
    else
    {
        reservoir = RTXDI_EmptyGIReservoir();
    }

    RTXDI_StoreGIReservoir(reservoir, g_Const.restirGIReservoirBufferParams, pixelCord, 0);
}