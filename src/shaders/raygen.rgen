#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable

layout( push_constant ) uniform Frame {
	uint frame;
	uint moved;
} f;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 1, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT Payload {
	bool missed;
	float metallicFactor;
  	float roughness;
	vec3 color;
  	vec3 emission;
	vec3 hitPoint;
	vec3 hitNormal;
} p;

#define PI 3.1415926

uint NextRandom(inout uint state) {
	state = state * 747796405 + 2891336453;
	uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

float RandomValue(inout uint state) {
	return NextRandom(state) / 4294967295.0;
}

float RandomValueNormalDistribution(inout uint state) {
	float theta = 2 * 3.1415926 * RandomValue(state);
	float rho = sqrt(-2 * log(RandomValue(state)));
	return rho * cos(theta);
}

vec3 RandomDirection(inout uint state) {
	float x = RandomValueNormalDistribution(state);
	float y = RandomValueNormalDistribution(state);
	float z = RandomValueNormalDistribution(state);
	return normalize(vec3(x,y,z));
}

const float tmin = 0.1;
const float tmax = 10000.0;

vec3 Trace(vec3 direction, vec3 origin, inout uint state) {
	vec3 incomingLight = vec3(0.0);
	vec3 rayColor = vec3(1.0);

	for (int i = 0; i <= 10; i++) {
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);
		if (!p.missed) {
			origin = p.hitPoint;
			vec3 sepecular = reflect(direction, p.hitNormal);
			vec3 difuse = normalize(p.hitNormal + RandomDirection(state));
			bool isSpecularBounce = p.metallicFactor >= RandomValue(state);
			direction = mix(sepecular, difuse, p.roughness  * float(isSpecularBounce));
			direction = difuse;
			if (f.moved == 1) {
				return p.color;
			}
			incomingLight += p.emission * 6.4 * rayColor;
			rayColor *= mix(p.color, vec3(1.0), float(isSpecularBounce));

			float p = max(rayColor.r, max(rayColor.g, rayColor.b));
			if (RandomValue(state) >= p) {
				break;
			}
			rayColor *= 1.0 / p; 
		}else {
			// const float dotp = dot(direction, normalize(vec3(1.0, 10.0, 1.0)));
			// if (dotp > 0.9) {
			// 	incomingLight += dotp * vec3(0.99215, 0.9843, 0.82745) * 40 * rayColor;
			// }
			break;
		}
	}
	return incomingLight;
}
const int raysPerPixel = 10;

void main() 
{	
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

	uint rngState = uint((gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x) + gl_LaunchIDEXT.x) + uint(f.frame) * 23145;

	vec3 totalLight = vec3(0.0);

	for (int ray = 0; ray < raysPerPixel; ray++) {
		vec3 incomingLight = Trace(direction.xyz, origin.xyz, rngState);
		totalLight += incomingLight;
	}

	vec3 pixelCol = totalLight / raysPerPixel;
	vec3 color;
	if (f.moved == 0) {
		float a =1.0 / float(f.frame+1.0);
		vec3 oldColor = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
		color = vec3(mix(oldColor, pixelCol, a));
	}else{
		color = pixelCol;
	}

	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color,0.0));
}