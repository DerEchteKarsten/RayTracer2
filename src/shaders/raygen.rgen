#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 1, rgba8) uniform image2D image;
layout(binding = 2, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT Payload {
	bool missed;
	float metallicFactor;
  	float roughness;
	vec3 color;
  	vec3 emission;
	vec3 hitPoint;
	vec3 hitNormal;
} p;

#define PI 3.1415926

float RandomValue(inout uint state) {
	state *= (state +1231290) * (state +46729036) * (state +2455676);
	return state / 424967295.0;
}

float RandomValueNormal(inout uint state) {
	float theta = 2 * PI * RandomValue(state);
	float rho = sqrt(-2 * log(RandomValue(state)));
	return rho * cos(theta);
}

vec3 RandomDirection(inout uint state) {
	float x = RandomValueNormal(state);
	float y = RandomValueNormal(state);
	float z = RandomValueNormal(state);
	return normalize(vec3(x,y,z));
}

const int raysPerPixel = 5;

const float tmin = 0.1;
const float tmax = 1000.0;

vec3 Trace(vec3 direction, vec3 origin) {
	vec3 incomingLight = vec3(0.0);
	vec3 rayColor = vec3(1.0);

	for (int i = 0; i < 2; i++) {
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, tmin, direction, tmax, 0);
		if (!p.missed) {
			origin = p.hitPoint;
			direction = reflect(direction, p.hitNormal);
			// if (i == 1) {
			// 	return direction;
			// }
			// rayColor = vec3(1.0, 0.0, 1.0);
			//incomingLight += (p.emission * 200) * rayColor;
		}else {
			rayColor = vec3(1.0, 0.0, 0.0);
			break;
		}
	}
	return rayColor;
}

void main() 
{	
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

	//uint rngState = uint(inUV.y * gl_LaunchSizeEXT.x + inUV.y);

	// vec3 totalLight = vec3(0.0);

	// for (int ray = 0; ray < raysPerPixel; ray++) {
	// 	light += incomingLight;
	// }

	vec3 pixelCol = Trace(direction.xyz, origin.xyz);
	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(pixelCol, 0.0));
}