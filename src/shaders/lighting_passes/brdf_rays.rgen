#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_tracing : require

#include "../common.glsl"

layout(location = 0) rayPayloadEXT Payload p;

#include "RtxdiApplicationBridge.glsl"
#include "rtxdi/InitialSamplingFunctions.hlsli"
#include "rtxdi/DIResamplingFunctions.hlsli"
#include "rtxdi/GIResamplingFunctions.hlsli"
#include "ShadingHelpers.glsl"

const uint numPrimaryLocalLightSamples = 1;
const uint numPrimaryInfiniteLightSamples = 1;
const uint numPrimaryEnvironmentSamples = 1;

const float SKYBOX = 1.0;
const float c_MaxIndirectRadiance = 100.0;


void main() 
{	
	

    RTXDI_GIReservoir reservoir;

    vec3 p_emission = p.emission;

    if (RAB_IsSurfaceValid(primary.surface))
    {
        RAB_RandomSamplerState rng = RAB_InitRandomSampler(pixelCord, 1);
        
        float dist = max(1, 0.1 * length(primary.surface.worldPos - g_Const.view.cameraDirectionOrPosition.xyz));

        RayDesc ray;
        ray.TMin = 0.001f * dist;
        ray.TMax = 1000;

        float3 tangent, bitangent;
        branchlessONB(primary.surface.normal, tangent, bitangent);

        float2 Rand;
        Rand.x = RAB_GetNextRandom(rng);
        Rand.y = RAB_GetNextRandom(rng);

        float3 V = normalize(g_Const.view.cameraDirectionOrPosition.xyz - primary.surface.worldPos);

        bool isSpecularRay = false;
        bool isDeltaSurface = primary.surface.roughness == 0.0;
        float specular_PDF;
        float3 BRDF_over_PDF;
        float overall_PDF;

        {
            float3 specularDirection;
            float3 specular_BRDF_over_PDF;
            {
                float3 Ve = float3(dot(V, tangent), dot(V, bitangent), dot(V, primary.surface.normal));
                float3 He = sampleGGX_VNDF(Ve, primary.surface.roughness, Rand);
                float3 H = isDeltaSurface ? primary.surface.normal : normalize(He.x * tangent + He.y * bitangent + He.z * primary.surface.normal);
                specularDirection = reflect(-V, H);

                float HoV = saturate(dot(H, V));
                float NoV = saturate(dot(primary.surface.normal, V));
                float3 F = Schlick_Fresnel(primary.surface.specularF0, HoV);
                float G1 = isDeltaSurface ? 1.0 : (NoV > 0) ? G1_Smith(primary.surface.roughness, NoV) : 0;
                specular_BRDF_over_PDF = F * G1;
            }

            float3 diffuseDirection;
            float diffuse_BRDF_over_PDF;
            {
                float solidAnglePdf;
                float3 localDirection = SampleCosHemisphere(Rand, solidAnglePdf);
                diffuseDirection = tangent * localDirection.x + bitangent * localDirection.y + primary.surface.normal * localDirection.z;
                diffuse_BRDF_over_PDF = 1.0;
            }

            specular_PDF = saturate(calcLuminance(specular_BRDF_over_PDF) /
                calcLuminance(specular_BRDF_over_PDF + diffuse_BRDF_over_PDF * primary.surface.diffuseAlbedo));

            isSpecularRay = RAB_GetNextRandom(rng) < specular_PDF;

            if (isSpecularRay)
            {
                ray.Direction = specularDirection;
                BRDF_over_PDF = specular_BRDF_over_PDF / specular_PDF;
            }
            else
            {
                ray.Direction = diffuseDirection;
                BRDF_over_PDF = vec3(diffuse_BRDF_over_PDF / (1.0 - specular_PDF));
            }

            const float specularLobe_PDF = ImportanceSampleGGX_VNDF_PDF(primary.surface.roughness, primary.surface.normal, V, ray.Direction);
            const float diffuseLobe_PDF = saturate(dot(ray.Direction, primary.surface.normal)) / RTXDI_PI;

            // For delta surfaces, we only pass the diffuse lobe to ReSTIR GI, and this pdf is for that.
            overall_PDF = isDeltaSurface ? diffuseLobe_PDF : mix(diffuseLobe_PDF, specularLobe_PDF, specular_PDF);
        }

        if (dot(primary.surface.geoNormal, ray.Direction) <= 0.0)
        {
            BRDF_over_PDF = vec3(0.0);
            ray.TMax = 0;
        }

        ray.Origin = primary.surface.worldPos;

        RAB_Surface secondarySurface = TraceRayToSurface(ray);
        float3 radiance = p.emission;

        if(RAB_IsSurfaceValid(secondarySurface)) {

            RTXDI_SampleParameters sampleParams = RTXDI_InitSampleParameters(
                numPrimaryLocalLightSamples,
                numPrimaryInfiniteLightSamples,
                numPrimaryEnvironmentSamples,
                0,      // numBrdfSamples
                0.f,    // brdfCutoff 
                0.f     // brdfMinRayT
            );   

            RAB_RandomSamplerState tileRng = RAB_InitRandomSampler(pixelCord / RTXDI_TILE_SIZE_IN_PIXELS, 1);

            RAB_LightSample lightSample;
            RTXDI_DIReservoir DIreservoir = RTXDI_SampleLightsForSurface(rng, tileRng, secondarySurface,
                sampleParams, g_Const.lightBufferParams, g_Const.restirDI.initialSamplingParams.localLightSamplingMode,
                    g_Const.localLightsRISBufferSegmentParams, g_Const.environmentLightRISBufferSegmentParams,
            lightSample);

            // Try to find this secondary surface in the G-buffer. If found, resample the lights
            // from that G-buffer surface into the reservoir using the spatial resampling function.

            float4 secondaryClipPos = mul(float4(secondarySurface.worldPos, 1.0), g_Const.view.matWorldToClip);
            secondaryClipPos.xyz /= secondaryClipPos.w;

            // if ((abs(secondaryClipPos.x) < 1.0 && abs(secondaryClipPos.y) < 1.0) && secondaryClipPos.w > 0)
            // {
            //     int2 secondaryPixelPos = int2(secondaryClipPos.xy * g_Const.view.clipToWindowScale + g_Const.view.clipToWindowBias);
            //     secondarySurface.viewDepth = secondaryClipPos.w;

            //     RTXDI_DISpatialResamplingParameters sparams;
            //     sparams.sourceBufferIndex = g_Const.restirDI.bufferIndices.shadingInputBufferIndex;
            //     sparams.numSamples = g_Const.restirDI.spatialResamplingParams.numSpatialSamples;
            //     sparams.numDisocclusionBoostSamples = 0;
            //     sparams.targetHistoryLength = 0;
            //     sparams.biasCorrectionMode = g_Const.restirDI.spatialResamplingParams.spatialBiasCorrection;
            //     sparams.samplingRadius = g_Const.restirDI.spatialResamplingParams.spatialSamplingRadius;
            //     sparams.depthThreshold = g_Const.restirDI.spatialResamplingParams.spatialDepthThreshold;
            //     sparams.normalThreshold = g_Const.restirDI.spatialResamplingParams.spatialNormalThreshold;
            //     sparams.enableMaterialSimilarityTest = false;
            //     sparams.discountNaiveSamples = false;

            //     DIreservoir = RTXDI_DISpatialResampling(secondaryPixelPos, secondarySurface, DIreservoir,
            //         rng, g_Const.runtimeParams, g_Const.restirDI.reservoirBufferParams, sparams, lightSample);
            // }

            float3 indirectDiffuse = vec3(0);
            float3 indirectSpecular = vec3(0);
            float lightDistance = 0;
            ShadeSurfaceWithLightSample(DIreservoir, secondarySurface, lightSample, /* previousFrameTLAS = */ false,
                /* enableVisibilityReuse = */ false, indirectDiffuse, indirectSpecular, lightDistance);

            radiance += indirectDiffuse * secondarySurface.diffuseAlbedo + indirectSpecular;

            // Firefly suppression
            float indirectLuminance = calcLuminance(radiance);
            if (indirectLuminance > c_MaxIndirectRadiance)
                radiance *= c_MaxIndirectRadiance / indirectLuminance;

            // outputShadingResult = isSpecularRay && isDeltaSurface;

            // if (isValidSecondarySurface && !outputShadingResult)
            // {
            //     // This pixel has a valid indirect sample so it stores information as an initial GI reservoir.
            // }
            //texture(t_LocalLightPdfTexture, vec2(pixelCord) / vec2(size)).rrr
            reservoir = RTXDI_MakeGIReservoir(secondarySurface.worldPos,
                secondarySurface.normal, radiance, overall_PDF);

        }else {
            reservoir = RTXDI_MakeGIReservoir(ray.Origin + ray.Direction * BACKGROUND_DEPTH,
                -ray.Direction, (p.color.rgb * SKYBOX + p_emission), overall_PDF);
        }
    }
    else
    {
        reservoir = RTXDI_EmptyGIReservoir();
    }
    RTXDI_StoreGIReservoir(reservoir, g_Const.restirGI.reservoirBufferParams, pixelCord, g_Const.restirGI.bufferIndices.secondarySurfaceReSTIRDIOutputBufferIndex);
}