#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"
layout(location = 0) rayPayloadEXT Payload p;
layout( push_constant ) uniform Frame {
	uint frame;
	uint moved;
} f;


layout(binding = 0, set = 1, r32f) uniform image2D u_GBufferDepth;
layout(binding = 1, set = 1, r32ui) uniform uimage2D u_GBufferNormals;
layout(binding = 2, set = 1, r32ui) uniform uimage2D u_GBufferGeoNormals;
layout(binding = 3, set = 1, r32ui) uniform uimage2D u_GBufferDiffuseAlbedo;
layout(binding = 4, set = 1, r32ui) uniform uimage2D u_GBufferSpecularRough;
layout(binding = 5, set = 1, rgba32f) uniform image2D u_MotionVectors;
layout(binding = 8, set = 0) uniform sampler2D skyBox;

#define RTXDI_ENABLE_PRESAMPLING 0
#define RTXDI_GLSL
#include "RtxdiApplicationBridge.glsl"
#include "rtxdi/GIResamplingFunctions.hlsli"

layout(binding = 11, set = 0, std430) buffer Inputs {
    float outputs[][3];
};


void main() {
    uint2 pixelPosition = RTXDI_ReservoirPosToPixelPos(gl_LaunchIDEXT.xy, g_Const.runtimeParams.activeCheckerboardField);

    RAB_RandomSamplerState rng = RAB_InitRandomSampler(gl_LaunchIDEXT.xy, 7);
    
    const RAB_Surface primarySurface = RAB_GetGBufferSurface(ivec2(pixelPosition), false);
    
    const uint2 reservoirPosition = RTXDI_PixelPosToReservoirPos(pixelPosition, g_Const.runtimeParams.activeCheckerboardField);
    RTXDI_GIReservoir reservoir = RTXDI_LoadGIReservoir(g_Const.restirGI.reservoirBufferParams, reservoirPosition, g_Const.restirGI.bufferIndices.secondarySurfaceReSTIRDIOutputBufferIndex);

    float3 motionVector = imageLoad(u_MotionVectors, ivec2(pixelPosition)).xyz;
    motionVector = convertMotionVectorToPixelSpace(g_Const.view, g_Const.prevView, ivec2(pixelPosition), motionVector);

    if (RAB_IsSurfaceValid(primarySurface)) {
        if(reservoir.M != 1 && reservoir.radiance == vec3(0.0)) {
            reservoir.M = 1;
            reservoir.radiance = vec3(outputs[reservoir.M][0], outputs[reservoir.M][1], outputs[reservoir.M][2]);
        }

        RTXDI_GITemporalResamplingParameters tParams;

        tParams.screenSpaceMotion = motionVector;
        tParams.sourceBufferIndex = g_Const.restirGI.bufferIndices.temporalResamplingInputBufferIndex;
        tParams.maxHistoryLength = g_Const.restirGI.temporalResamplingParams.maxHistoryLength;
        tParams.biasCorrectionMode = g_Const.restirGI.temporalResamplingParams.temporalBiasCorrectionMode;
        tParams.depthThreshold = g_Const.restirGI.temporalResamplingParams.depthThreshold;
        tParams.normalThreshold = g_Const.restirGI.temporalResamplingParams.normalThreshold;
        tParams.enablePermutationSampling = g_Const.restirGI.temporalResamplingParams.enablePermutationSampling == 1;
        tParams.enableFallbackSampling = g_Const.restirGI.temporalResamplingParams.enableFallbackSampling == 1;
        tParams.uniformRandomNumber = g_Const.restirGI.temporalResamplingParams.uniformRandomNumber;

        // Age threshold should vary.
        // This is to avoid to die a bunch of GI reservoirs at once at a disoccluded area.
        tParams.maxReservoirAge = uint(g_Const.restirGI.temporalResamplingParams.maxReservoirAge * (0.5 + RAB_GetNextRandom(rng) * 0.5));

        // Execute resampling.
        reservoir = RTXDI_GITemporalResampling(pixelPosition, primarySurface, reservoir, rng, g_Const.runtimeParams, g_Const.restirGI.reservoirBufferParams, tParams);
    }

#ifdef RTXDI_ENABLE_BOILING_FILTER
    if (g_Const.restirGI.temporalResamplingParams.enableBoilingFilter)
    {
        RTXDI_GIBoilingFilter(LocalIndex, g_Const.restirGI.temporalResamplingParams.boilingFilterStrength, reservoir);
    }
#endif

    RTXDI_StoreGIReservoir(reservoir, g_Const.restirGI.reservoirBufferParams, reservoirPosition, g_Const.restirGI.bufferIndices.temporalResamplingOutputBufferIndex);
}